import enum

from django.db import models
from django.utils import timezone
from django.utils.translation import gettext_lazy as _


class NumeratorManager(models.Manager):
    def get_queryset(self):
        return super().get_queryset()

    def get_by_natural_key(self, ctype, date_start, date_end):
        return self.get(ctype=ctype, date_start=date_start, date_end=date_end)


class NumeratorReset(enum.Enum):
    YEARLY = "YEAR"
    MONTHLY = "MONTH"
    FIXED = "NEVER"


class Numerator(models.Model):
    """ContentTypeCounter is used as autogenerated number register
    like autonumber for uuid based Model"""

    objects = NumeratorManager()

    app_label = models.CharField(
        max_length=50,
        verbose_name=_("application"),
    )
    model = models.CharField(
        max_length=50,
        verbose_name=_("model"),
    )
    prefix = models.CharField(
        max_length=50,
        null=True,
        blank=True,
        verbose_name=_("prefix"),
    )
    reset_mode = models.CharField(
        max_length=50,
        choices=[(str(x.value), str(x.name)) for x in NumeratorReset],
        default=NumeratorReset.YEARLY.value,
        verbose_name=_("reset mode"),
    )
    year = models.IntegerField()
    month = models.IntegerField(default=0)
    counter = models.PositiveIntegerField(
        default=0,
        verbose_name=_("Counter"),
    )

    class Meta:
        verbose_name = _("Numerator")
        verbose_name_plural = _("Numerators")
        unique_together = (
            "app_label",
            "model",
            "prefix",
            "reset_mode",
            "year",
            "month",
        )

    def __str__(self):
        return str(self.model)

    def natural_key(self):
        natural_key = (self.app_label, self.model, self.year, self.month)
        return natural_key

    def increase_counter(self):
        self.counter += 1
        return self.counter

    def decrease_counter(self):
        i = 1 if self.counter > 0 else 0
        self.counter -= i
        return self.counter

    def reset_counter(self):
        self.counter = 0
        return self.counter

    @staticmethod
    def get_for_instance(obj):
        opts = obj._meta
        get_matrix = {
            "app_label": opts.app_label,
            "model": (opts.model_name if not obj.parent_prefix else obj.parent_model),
            "prefix": obj.get_doc_prefix(),
        }
        create_matrix = {
            "app_label": opts.app_label,
            "model": (opts.model_name if not obj.parent_prefix else obj.parent_model),
            "prefix": obj.get_doc_prefix(),
            "year": obj.get_date_field().year,
            "month": obj.get_date_field().month
            if obj.reset_mode == NumeratorReset.MONTHLY
            else 0,
            "reset_mode": obj.reset_mode,
        }
        get_or_create = Numerator.objects.get_or_create
        ct_counter, created = get_or_create(**get_matrix, defaults=create_matrix)
        return ct_counter


class NumeratorMixinBase(models.Model):

    zero_fill = 4
    doc_prefix = ""
    numerator = None
    parent_prefix = False
    parent_model = None
    inner_id_field = "inner_id"
    create_date_field = "created_at"
    reset_mode = NumeratorReset.YEARLY

    reg_number = models.PositiveIntegerField(
        null=True,
        blank=True,
        editable=False,
        verbose_name=_("Reg number"),
    )

    class Meta:
        abstract = True

    def get_doc_prefix(self):
        """
        Give numerator unique prefix, doc prefix is Mandatory for
        Polymorphic Based Child Model, each child should implement unique doc_prefix,
        Override this method if custom prefix is needed
        """
        doc_prefix = getattr(self, "doc_prefix", "")
        return doc_prefix

    def get_date_field(self):
        return getattr(self, self.create_date_field)

    def get_inner_id_field(self):
        return getattr(self, self.inner_id_field)

    def format_date(self, form="%y%m"):
        """Format date to string"""
        return self.get_date_field().strftime(form)

    def format_number(self):
        """Format register number digit lead by zero"""
        return str(self.reg_number).zfill(self.zero_fill)

    def format_inner_id(self):
        """Inner ID final format"""
        form = [self.get_doc_prefix(), self.format_date(), self.format_number()]
        inner_id = "{}{}{}".format(*form)
        return setattr(self, self.inner_id_field, inner_id)

    def get_numerator(self):
        """Get or create numerator"""
        numerator = Numerator.get_for_instance(self)
        return numerator

    def update_inner_id(self):
        """
        Register and get Numerator instance for
        this model, Get latest counter value and then
        generate and set inner_id
        """
        # Get Numerator instance for this model
        if self.numerator is None:
            self.numerator = self.get_numerator()

        # If reg_number is None get new one
        if self.reg_number is None:
            self.reg_number = self.numerator.increase_counter()

        # If reg number > counter set new counter value
        if self.reg_number > self.numerator.counter:
            self.numerator.counter = self.reg_number

        return self.format_inner_id()

    def save(self, *args, **kwargs):
        if self.numerator is None:
            self.update_inner_id()
        self.numerator.save()
        super().save(*args, **kwargs)


class NumeratorMixin(NumeratorMixinBase):
    """Mixin for Numerator Model"""

    inner_id = models.CharField(
        null=True,
        blank=True,
        unique=True,
        editable=False,
        max_length=50,
        verbose_name=_("Inner ID"),
    )
    created_at = models.DateTimeField(
        default=timezone.now,
        editable=False,
        verbose_name=_("created at"),
    )

    inner_id_field = "inner_id"
    create_date_field = "created_at"

    class Meta:
        abstract = True
